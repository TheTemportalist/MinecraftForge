++++ REJECTED PATCH 1
                             this.playerEntity.ridingEntity.updateRiderPosition();
                         }
 
+                        if (!this.hasMoved) return; //Fixes teleportation kick while riding entities
+
                         this.serverController.getConfigurationManager().serverUpdateMountedMovingPlayer(this.playerEntity);
 
                         if (this.playerEntity.ridingEntity != null)
++++ END PATCH
++++ REJECTED PATCH 2
                         this.playerEntity.jump();
                     }
 
+                    if (!this.hasMoved) return; //Fixes "Moved Too Fast" kick when being teleported while moving
+
                     this.playerEntity.moveEntity(d11, d12, d13);
                     this.playerEntity.onGround = packetIn.isOnGround();
                     d11 = d8 - this.playerEntity.posX;
++++ END PATCH
++++ REJECTED PATCH 3
                         logger.warn(this.playerEntity.getName() + " moved wrongly!");
                     }
 
+                    if (!this.hasMoved) return; //Fixes "Moved Too Fast" kick when being teleported while moving
+
                     this.playerEntity.setPositionAndRotation(d8, d9, d10, f1, f2);
                     this.playerEntity.addMovementStat(this.playerEntity.posX - d0, this.playerEntity.posY - d1, this.playerEntity.posZ - d2);
 
++++ END PATCH
++++ REJECTED PATCH 4
                     {
                         boolean flag2 = worldserver.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.getEntityBoundingBox().contract((double)f3, (double)f3, (double)f3)).isEmpty();
 
-                        if (flag && (flag1 || !flag2) && !this.playerEntity.isPlayerSleeping())
+                        if (flag && (flag1 || !flag2) && !this.playerEntity.isPlayerSleeping() && !this.playerEntity.noClip)
                         {
                             this.setPlayerLocation(this.lastPosX, this.lastPosY, this.lastPosZ, f1, f2);
                             return;
++++ END PATCH
++++ REJECTED PATCH 5
                         this.floatingTickCount = 0;
                     }
 
+                    if (!this.hasMoved) return; //Fixes "Moved Too Fast" kick when being teleported while moving
+
                     this.playerEntity.onGround = packetIn.isOnGround();
                     this.serverController.getConfigurationManager().serverUpdateMountedMovingPlayer(this.playerEntity);
                     this.playerEntity.handleFalling(this.playerEntity.posY - d7, packetIn.isOnGround());
++++ END PATCH
++++ REJECTED PATCH 7
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         ItemStack itemstack = this.playerEntity.inventory.getCurrentItem();
         boolean flag = false;
+        boolean placeResult = true;
         BlockPos blockpos = packetIn.getPosition();
         EnumFacing enumfacing = EnumFacing.getFront(packetIn.getPlacedBlockDirection());
         this.playerEntity.markPlayerActive();
++++ END PATCH
++++ REJECTED PATCH 8
                 return;
             }
 
+            net.minecraftforge.event.entity.player.PlayerInteractEvent event = net.minecraftforge.event.ForgeEventFactory.onPlayerInteract(playerEntity, net.minecraftforge.event.entity.player.PlayerInteractEvent.Action.RIGHT_CLICK_AIR, worldserver, new BlockPos(0, 0, 0), null, new net.minecraft.util.Vec3(packetIn.getPlacedBlockOffsetX(), packetIn.getPlacedBlockOffsetY(), packetIn.getPlacedBlockOffsetZ()));
+            if (event.useItem != net.minecraftforge.fml.common.eventhandler.Event.Result.DENY)
+            {
             this.playerEntity.theItemInWorldManager.tryUseItem(this.playerEntity, worldserver, itemstack);
+            }
         }
         else if (blockpos.getY() < this.serverController.getBuildLimit() - 1 || enumfacing != EnumFacing.UP && blockpos.getY() < this.serverController.getBuildLimit())
         {
-            if (this.hasMoved && this.playerEntity.getDistanceSq((double)blockpos.getX() + 0.5D, (double)blockpos.getY() + 0.5D, (double)blockpos.getZ() + 0.5D) < 64.0D && !this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos))
+            double dist = playerEntity.theItemInWorldManager.getBlockReachDistance() + 3;
+            dist *= dist;
+            if (this.hasMoved && this.playerEntity.getDistanceSq((double)blockpos.getX() + 0.5D, (double)blockpos.getY() + 0.5D, (double)blockpos.getZ() + 0.5D) < dist && !this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos))
             {
-                this.playerEntity.theItemInWorldManager.activateBlockOrUseItem(this.playerEntity, worldserver, itemstack, blockpos, enumfacing, packetIn.getPlacedBlockOffsetX(), packetIn.getPlacedBlockOffsetY(), packetIn.getPlacedBlockOffsetZ());
+                // record block place result so we can update client itemstack size if place event was cancelled.
+                placeResult = this.playerEntity.theItemInWorldManager.activateBlockOrUseItem(this.playerEntity, worldserver, itemstack, blockpos, enumfacing, packetIn.getPlacedBlockOffsetX(), packetIn.getPlacedBlockOffsetY(), packetIn.getPlacedBlockOffsetZ());
             }
 
             flag = true;
++++ END PATCH
++++ REJECTED PATCH 9
             this.playerEntity.isChangingQuantityOnly = true;
             this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = ItemStack.copyItemStack(this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem]);
             Slot slot = this.playerEntity.openContainer.getSlotFromInventory(this.playerEntity.inventory, this.playerEntity.inventory.currentItem);
+            int windowId = this.playerEntity.openContainer.windowId;
+            if  (slot == null) // Forge: Fix 'slotless' inventories not selecting a valid slot to update
+            {
+                slot = this.playerEntity.inventoryContainer.getSlotFromInventory(this.playerEntity.inventory, this.playerEntity.inventory.currentItem);
+                windowId = this.playerEntity.inventoryContainer.windowId;
+            }
             this.playerEntity.openContainer.detectAndSendChanges();
             this.playerEntity.isChangingQuantityOnly = false;
 
-            if (!ItemStack.areItemStacksEqual(this.playerEntity.inventory.getCurrentItem(), packetIn.getStack()))
+            if (!ItemStack.areItemStacksEqual(this.playerEntity.inventory.getCurrentItem(), packetIn.getStack()) || !placeResult) // force client itemstack update if place event was cancelled
             {
-                this.sendPacket(new S2FPacketSetSlot(this.playerEntity.openContainer.windowId, slot.slotNumber, this.playerEntity.inventory.getCurrentItem()));
+                this.sendPacket(new S2FPacketSetSlot(windowId, slot.slotNumber, this.playerEntity.inventory.getCurrentItem()));
             }
         }
     }
++++ END PATCH
++++ REJECTED PATCH 10
             }
             else
             {
-                IChatComponent ichatcomponent = new ChatComponentTranslation("chat.type.text", new Object[] {this.playerEntity.getDisplayName(), s});
-                this.serverController.getConfigurationManager().sendChatMsgImpl(ichatcomponent, false);
+                ChatComponentTranslation chatcomponenttranslation1 = new ChatComponentTranslation("chat.type.text", this.playerEntity.getDisplayName(), net.minecraftforge.common.ForgeHooks.newChatWithLinks(s));
+                IChatComponent chat = net.minecraftforge.common.ForgeHooks.onServerChatEvent(this, s, chatcomponenttranslation1);
+                if (chat == null) return;
+                this.serverController.getConfigurationManager().sendChatMsgImpl(chat, false);
             }
 
             this.chatSpamThresholdCount += 20;
++++ END PATCH
++++ REJECTED PATCH 11
                         return;
                     }
 
-                    this.playerEntity = this.serverController.getConfigurationManager().recreatePlayerEntity(this.playerEntity, 0, false);
+                    this.playerEntity = this.serverController.getConfigurationManager().recreatePlayerEntity(this.playerEntity, playerEntity.dimension, false);
                 }
 
                 break;
++++ END PATCH
