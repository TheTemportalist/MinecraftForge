++++ REJECTED PATCH 1
                 {
                     Block block = this.getBlock0(j, l - 1, k);
 
-                    if (block.getLightOpacity() != 0)
+                    if (getBlockLightOpacity(j, l - 1, k) != 0)
                     {
                         this.heightMap[k << 4 | j] = l;
 
++++ END PATCH
++++ REJECTED PATCH 2
 
     public int getBlockLightOpacity(BlockPos pos)
     {
-        return this.getBlock(pos).getLightOpacity();
+        return this.getBlock(pos).getLightOpacity(worldObj, pos);
     }
 
     private int getBlockLightOpacity(int x, int y, int z)
     {
-        return this.getBlock0(x, y, z).getLightOpacity();
+        return getBlockLightOpacity(new BlockPos((xPosition << 4) + x, y, (zPosition << 4) + z));
     }
 
     private Block getBlock0(int x, int y, int z)
++++ END PATCH
++++ REJECTED PATCH 5
                 }
                 else
                 {
-                    int j1 = block.getLightOpacity();
-                    int k1 = block1.getLightOpacity();
+                    int j1 = block.getLightOpacity(this.worldObj, pos);
 
                     if (j1 > 0)
                     {
++++ END PATCH
++++ REJECTED PATCH 8
     private TileEntity createNewTileEntity(BlockPos pos)
     {
         Block block = this.getBlock(pos);
-        return !block.hasTileEntity() ? null : ((ITileEntityProvider)block).createNewTileEntity(this.worldObj, this.getBlockMetadata(pos));
+        IBlockState state = block.getStateFromMeta(this.getBlockMetadata(pos));
+        return !block.hasTileEntity(state) ? null : block.createTileEntity(this.worldObj, state);
     }
 
     public TileEntity getTileEntity(BlockPos pos, Chunk.EnumCreateEntityType p_177424_2_)
     {
         TileEntity tileentity = (TileEntity)this.chunkTileEntityMap.get(pos);
 
+        if (tileentity != null && tileentity.isInvalid())
+        {
+            chunkTileEntityMap.remove(pos);
+            tileentity = null;
+        }
+
         if (tileentity == null)
         {
             if (p_177424_2_ == Chunk.EnumCreateEntityType.IMMEDIATE)
++++ END PATCH
++++ REJECTED PATCH 10
         tileEntityIn.setWorldObj(this.worldObj);
         tileEntityIn.setPos(pos);
 
-        if (this.getBlock(pos) instanceof ITileEntityProvider)
+        if (this.getBlock(pos).hasTileEntity(getBlock(pos).getStateFromMeta(this.getBlockMetadata(pos))))
         {
             if (this.chunkTileEntityMap.containsKey(pos))
             {
++++ END PATCH
++++ REJECTED PATCH 16
         while (!this.tileEntityPosQueue.isEmpty())
         {
             BlockPos blockpos = (BlockPos)this.tileEntityPosQueue.poll();
+            Block block = this.getBlock(blockpos);
+            IBlockState state = block.getStateFromMeta(this.getBlockMetadata(blockpos));
 
-            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlock(blockpos).hasTileEntity())
+            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && block.hasTileEntity(state))
             {
                 TileEntity tileentity = this.createNewTileEntity(blockpos);
                 this.worldObj.setTileEntity(blockpos, tileentity);
++++ END PATCH
++++ REJECTED PATCH 17
     @SideOnly(Side.CLIENT)
     public void fillChunk(byte[] p_177439_1_, int p_177439_2_, boolean p_177439_3_)
     {
+        for(TileEntity tileEntity : chunkTileEntityMap.values())
+        {
+            tileEntity.updateContainingBlockInfo();
+            tileEntity.getBlockMetadata();
+            tileEntity.getBlockType();
+        }
+
         int i = 0;
         boolean flag = !this.worldObj.provider.getHasNoSky();
 
++++ END PATCH
