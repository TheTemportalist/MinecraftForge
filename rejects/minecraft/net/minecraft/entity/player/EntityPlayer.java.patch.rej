++++ REJECTED PATCH 1
 @SuppressWarnings("incomplete-switch")
 public abstract class EntityPlayer extends EntityLivingBase
 {
+    public static final String PERSISTED_NBT_TAG = "PlayerPersisted";
+    private java.util.HashMap<Integer, BlockPos> spawnChunkMap = new java.util.HashMap<Integer, BlockPos>();
+    private java.util.HashMap<Integer, Boolean> spawnForcedMap = new java.util.HashMap<Integer, Boolean>();
+    public float eyeHeight = this.getDefaultEyeHeight();
+
     public InventoryPlayer inventory = new InventoryPlayer(this);
     private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest();
     public Container inventoryContainer;
++++ END PATCH
++++ REJECTED PATCH 2
     {
         if (this.itemInUse != null)
         {
-            this.itemInUse.onPlayerStoppedUsing(this.worldObj, this, this.itemInUseCount);
+            if (!net.minecraftforge.event.ForgeEventFactory.onUseItemStop(this, itemInUse, this.itemInUseCount))
+                this.itemInUse.onPlayerStoppedUsing(this.worldObj, this, this.itemInUseCount);
         }
 
         this.clearItemInUse();
++++ END PATCH
++++ REJECTED PATCH 4
 
             if (itemstack == this.itemInUse)
             {
+                itemInUseCount = net.minecraftforge.event.ForgeEventFactory.onItemUseTick(this, itemInUse, itemInUseCount);
+                if (itemInUseCount <= 0)
+                {
+                    this.onItemUseFinish();
+                }
+                else
+                { // Forge Keep unindented to lower patch
+                itemInUse.getItem().onUsingTick(itemInUse, this, itemInUseCount); //Forge Added
                 if (this.itemInUseCount <= 25 && this.itemInUseCount % 4 == 0)
                 {
                     this.updateItemUse(itemstack, 5);
++++ END PATCH
++++ REJECTED PATCH 8
             int i = this.itemInUse.stackSize;
             ItemStack itemstack = this.itemInUse.onItemUseFinish(this.worldObj, this);
 
+            itemstack = net.minecraftforge.event.ForgeEventFactory.onItemUseFinish(this, itemInUse, itemInUseCount, itemstack);
             if (itemstack != this.itemInUse || itemstack != null && itemstack.stackSize != i)
             {
                 this.inventory.mainInventory[this.inventory.currentItem] = itemstack;
 
-                if (itemstack.stackSize == 0)
+                if (itemstack != null && itemstack.stackSize == 0)
                 {
                     this.inventory.mainInventory[this.inventory.currentItem] = null;
                 }
++++ END PATCH
++++ REJECTED PATCH 9
             this.cameraYaw = 0.0F;
             this.addMountedMovementStat(this.posX - d0, this.posY - d1, this.posZ - d2);
 
-            if (this.ridingEntity instanceof EntityPig)
+            if (this.ridingEntity instanceof EntityLivingBase && ((EntityLivingBase)ridingEntity).shouldRiderFaceForward(this))
             {
                 this.rotationPitch = f1;
                 this.rotationYaw = f;
-                this.renderYawOffset = ((EntityPig)this.ridingEntity).renderYawOffset;
+                this.renderYawOffset = ((EntityLivingBase)this.ridingEntity).renderYawOffset;
             }
         }
     }
++++ END PATCH
++++ REJECTED PATCH 14
             f /= 5.0F;
         }
 
-        return f;
+        f = net.minecraftforge.event.ForgeEventFactory.getBreakSpeed(this, state, f, pos);
+        return (f < 0 ? 0 : f);
     }
 
     public boolean canHarvestBlock(Block blockToHarvest)
     {
-        return this.inventory.canHeldItemHarvest(blockToHarvest);
+        return net.minecraftforge.event.ForgeEventFactory.doPlayerHarvestCheck(this, blockToHarvest, this.inventory.canHeldItemHarvest(blockToHarvest));
     }
 
     public void readEntityFromNBT(NBTTagCompound tagCompund)
++++ END PATCH
++++ REJECTED PATCH 18
     {
         if (!this.isEntityInvulnerable(damageSrc))
         {
+            damageAmount = net.minecraftforge.common.ForgeHooks.onLivingHurt(this, damageSrc, damageAmount);
+            if (damageAmount <= 0) return;
             if (!damageSrc.isUnblockable() && this.isBlocking() && damageAmount > 0.0F)
             {
                 damageAmount = (1.0F + damageAmount) * 0.5F;
             }
 
-            damageAmount = this.applyArmorCalculations(damageSrc, damageAmount);
+            damageAmount = net.minecraftforge.common.ISpecialArmor.ArmorProperties.applyArmor(this, inventory.armorInventory, damageSrc, damageAmount);
+            if (damageAmount <= 0) return;
             damageAmount = this.applyPotionDamageCalculations(damageSrc, damageAmount);
             float f = damageAmount;
             damageAmount = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
++++ END PATCH
++++ REJECTED PATCH 19
         }
         else
         {
+            if (!net.minecraftforge.event.ForgeEventFactory.canInteractWith(this, targetEntity)) return false;
             ItemStack itemstack = this.getCurrentEquippedItem();
             ItemStack itemstack1 = itemstack != null ? itemstack.copy() : null;
 
++++ END PATCH
++++ REJECTED PATCH 20
 
     public void destroyCurrentEquippedItem()
     {
+        ItemStack orig = getCurrentEquippedItem();
         this.inventory.setInventorySlotContents(this.inventory.currentItem, (ItemStack)null);
+        net.minecraftforge.event.ForgeEventFactory.onPlayerDestroyItem(this, orig);
     }
 
     public double getYOffset()
++++ END PATCH
++++ REJECTED PATCH 23
 
         this.setSize(0.2F, 0.2F);
 
-        if (this.worldObj.isBlockLoaded(bedLocation))
+        if (this.worldObj.isBlockLoaded(bedLocation) && worldObj.getBlockState(bedLocation).getBlock().isBed(worldObj, bedLocation, this))
         {
-            EnumFacing enumfacing = (EnumFacing)this.worldObj.getBlockState(bedLocation).getValue(BlockDirectional.FACING);
+            EnumFacing enumfacing = this.worldObj.getBlockState(bedLocation).getBlock().getBedDirection(worldObj, bedLocation);
             float f = 0.5F;
             float f1 = 0.5F;
 
++++ END PATCH
++++ REJECTED PATCH 27
         }
         else
         {
-            return BlockBed.getSafeExitLocation(worldIn, bedLocation, 0);
+            return worldIn.getBlockState(bedLocation).getBlock().getBedSpawnPosition(worldIn, bedLocation, null);
         }
     }
 
     @SideOnly(Side.CLIENT)
     public float getBedOrientationInDegrees()
     {
-        if (this.playerLocation != null)
+        if (this.playerLocation != null && worldObj.getBlockState(playerLocation).getBlock().isBed(worldObj, playerLocation, this))
         {
-            EnumFacing enumfacing = (EnumFacing)this.worldObj.getBlockState(this.playerLocation).getValue(BlockDirectional.FACING);
+            EnumFacing enumfacing = this.worldObj.getBlockState(this.playerLocation).getBlock().getBedDirection(worldObj, playerLocation);
 
             switch (enumfacing)
             {
++++ END PATCH
++++ REJECTED PATCH 30
         }
 
         EntityList.EntityEggInfo entitylist$entityegginfo = (EntityList.EntityEggInfo)EntityList.entityEggs.get(Integer.valueOf(EntityList.getEntityID(entityLivingIn)));
+        if (entitylist$entityegginfo == null) entitylist$entityegginfo = net.minecraftforge.fml.common.registry.EntityRegistry.getEggs().get(EntityList.getEntityString(entityLivingIn));
 
         if (entitylist$entityegginfo != null)
         {
++++ END PATCH
++++ REJECTED PATCH 31
     {
         if (stack != this.itemInUse)
         {
+            duration = net.minecraftforge.event.ForgeEventFactory.onItemUseStart(this, stack, duration);
+            if (duration <= 0) return;
             this.itemInUse = stack;
             this.itemInUseCount = duration;
 
++++ END PATCH
++++ REJECTED PATCH 33
         this.xpSeed = oldPlayer.xpSeed;
         this.theInventoryEnderChest = oldPlayer.theInventoryEnderChest;
         this.getDataWatcher().updateObject(10, Byte.valueOf(oldPlayer.getDataWatcher().getWatchableObjectByte(10)));
+
+        this.spawnChunkMap = oldPlayer.spawnChunkMap;
+        this.spawnForcedMap = oldPlayer.spawnForcedMap;
+
+        //Copy over a section of the Entity Data from the old player.
+        //Allows mods to specify data that persists after players respawn.
+        NBTTagCompound old = oldPlayer.getEntityData();
+        if (old.hasKey(PERSISTED_NBT_TAG))
+        {
+            getEntityData().setTag(PERSISTED_NBT_TAG, old.getCompoundTag(PERSISTED_NBT_TAG));
+        }
+        net.minecraftforge.event.ForgeEventFactory.onPlayerClone(this, oldPlayer, !respawnFromEnd);
     }
 
     protected boolean canTriggerWalking()
++++ END PATCH
++++ REJECTED PATCH 34
 
     public void setCurrentItemOrArmor(int slotIn, ItemStack stack)
     {
-        this.inventory.armorInventory[slotIn] = stack;
+        if (slotIn == 0) //Forge: Fix issue in Player where it doen't take into account selected item
+        {
+            this.inventory.mainInventory[this.inventory.currentItem] = stack;
+        }
+        else
+        {
+            this.inventory.armorInventory[slotIn - 1] = stack;
+        }
     }
 
     @SideOnly(Side.CLIENT)
++++ END PATCH
++++ REJECTED PATCH 35
 
     public IChatComponent getDisplayName()
     {
-        IChatComponent ichatcomponent = new ChatComponentText(ScorePlayerTeam.formatPlayerName(this.getTeam(), this.getName()));
+        IChatComponent ichatcomponent = new ChatComponentText("");
+        if (!prefixes.isEmpty()) for (net.minecraft.util.IChatComponent prefix : prefixes) ichatcomponent.appendSibling(prefix);
+        ichatcomponent.appendSibling(new ChatComponentText(ScorePlayerTeam.formatPlayerName(this.getTeam(), this.getDisplayNameString())));
+        if (!suffixes.isEmpty()) for (net.minecraft.util.IChatComponent suffix : suffixes) ichatcomponent.appendSibling(suffix);
         ichatcomponent.getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/msg " + this.getName() + " "));
         ichatcomponent.getChatStyle().setChatHoverEvent(this.getHoverEvent());
         ichatcomponent.getChatStyle().setInsertion(this.getName());
++++ END PATCH
