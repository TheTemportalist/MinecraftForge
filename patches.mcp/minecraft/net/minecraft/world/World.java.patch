--- ../src-base/minecraft/net/minecraft/world/World.java
+++ ../src-work/minecraft/net/minecraft/world/World.java
@@ -60,6 +60,13 @@
 
 public abstract class World implements IBlockAccess
 {
+    /**
+     * Used in the getEntitiesWithinAABB functions to expand the search area for entities.
+     * Modders should change this variable to a higher value if it is less then the radius
+     * of one of there entities.
+     */
+    public static double MAX_ENTITY_RADIUS = 2.0D;
+
     private int seaLevel = 63;
     protected boolean scheduledUpdatesAreImmediate;
     public final List<Entity> loadedEntityList = Lists.<Entity>newArrayList();
@@ -101,6 +108,10 @@
     private final WorldBorder worldBorder;
     int[] lightUpdateBlockList;
 
+    public boolean restoringBlockSnapshots = false;
+    public boolean captureBlockSnapshots = false;
+    public java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot>();
+
     protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client)
     {
         this.worldAccesses = Lists.newArrayList(new IWorldEventListener[] {this.field_184152_t});
@@ -115,6 +126,7 @@
         this.provider = providerIn;
         this.isRemote = client;
         this.worldBorder = providerIn.getWorldBorder();
+        perWorldStorage = new MapStorage((ISaveHandler)null);
     }
 
     public World init()
@@ -124,6 +136,11 @@
 
     public BiomeGenBase getBiomeGenForCoords(final BlockPos pos)
     {
+        return this.provider.getBiomeGenForCoords(pos);
+    }
+
+    public BiomeGenBase getBiomeGenForCoordsBody(final BlockPos pos)
+    {
         if (this.isBlockLoaded(pos))
         {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
@@ -194,7 +211,7 @@
 
     public boolean isAirBlock(BlockPos pos)
     {
-        return this.getBlockState(pos).func_185904_a() == Material.air;
+        return this.getBlockState(pos).getBlock().isAir(this.getBlockState(pos), this, pos);
     }
 
     public boolean isBlockLoaded(BlockPos pos)
@@ -291,23 +308,49 @@
         {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             Block block = newState.getBlock();
+
+            net.minecraftforge.common.util.BlockSnapshot blockSnapshot = null;
+            if (this.captureBlockSnapshots && !this.isRemote)
+            {
+                blockSnapshot = net.minecraftforge.common.util.BlockSnapshot.getBlockSnapshot(this, pos, flags);
+                this.capturedBlockSnapshots.add(blockSnapshot);
+            }
+            IBlockState oldState = getBlockState(pos);
+            int oldLight = oldState.getLightValue(this, pos);
+            int oldOpacity = oldState.getLightOpacity(this, pos);
+
             IBlockState iblockstate = chunk.setBlockState(pos, newState);
 
             if (iblockstate == null)
             {
+                if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
                 return false;
             }
             else
             {
-                if (newState.func_185891_c() != iblockstate.func_185891_c() || newState.func_185906_d() != iblockstate.func_185906_d())
+                if (newState.getLightOpacity(this, pos) != oldOpacity || newState.getLightValue(this, pos) != oldLight)
                 {
                     this.theProfiler.startSection("checkLight");
                     this.checkLight(pos);
                     this.theProfiler.endSection();
                 }
 
-                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && chunk.isPopulated())
+                if (blockSnapshot == null) // Don't notify clients or update physics while capturing blockstates
                 {
+                    this.markAndNotifyBlock(pos, chunk, iblockstate, newState, flags);
+                }
+                return true;
+            }
+        }
+    }
+
+    // Split off from original setBlockState(BlockPos, IBlockState, int) method in order to directly send client and physic updates
+    public void markAndNotifyBlock(BlockPos pos, Chunk chunk, IBlockState iblockstate, IBlockState newState, int flags)
+    {
+        {
+            {
+                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && (chunk == null || chunk.isPopulated()))
+                {
                     this.func_184138_a(pos, iblockstate, newState, flags);
                 }
 
@@ -317,11 +360,9 @@
 
                     if (newState.func_185912_n())
                     {
-                        this.updateComparatorOutputLevel(pos, block);
+                        this.updateComparatorOutputLevel(pos, newState.getBlock());
                     }
                 }
-
-                return true;
             }
         }
     }
@@ -336,7 +377,7 @@
         IBlockState iblockstate = this.getBlockState(pos);
         Block block = iblockstate.getBlock();
 
-        if (iblockstate.func_185904_a() == Material.air)
+        if (block.isAir(iblockstate, this, pos))
         {
             return false;
         }
@@ -409,6 +450,9 @@
 
     public void notifyNeighborsOfStateChange(BlockPos pos, Block blockType)
     {
+        if(net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), java.util.EnumSet.allOf(EnumFacing.class)).isCanceled())
+            return;
+
         this.notifyBlockOfStateChange(pos.west(), blockType);
         this.notifyBlockOfStateChange(pos.east(), blockType);
         this.notifyBlockOfStateChange(pos.down(), blockType);
@@ -419,6 +463,11 @@
 
     public void notifyNeighborsOfStateExcept(BlockPos pos, Block blockType, EnumFacing skipSide)
     {
+        java.util.EnumSet<EnumFacing> directions = java.util.EnumSet.allOf(EnumFacing.class);
+        directions.remove(skipSide);
+        if(net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), directions).isCanceled())
+            return;
+
         if (skipSide != EnumFacing.WEST)
         {
             this.notifyBlockOfStateChange(pos.west(), blockType);
@@ -514,7 +563,7 @@
                 {
                     IBlockState iblockstate = this.getBlockState(blockpos);
 
-                    if (iblockstate.func_185891_c() > 0 && !iblockstate.func_185904_a().isLiquid())
+                    if (iblockstate.getBlock().getLightOpacity(iblockstate, this, blockpos) > 0 && !iblockstate.func_185904_a().isLiquid())
                     {
                         return false;
                     }
@@ -782,7 +831,7 @@
 
     public boolean isDaytime()
     {
-        return this.skylightSubtracted < 4;
+        return this.provider.isDaytime();
     }
 
     public RayTraceResult rayTraceBlocks(Vec3d p_72933_1_, Vec3d p_72933_2_)
@@ -982,6 +1031,13 @@
 
     public void func_184148_a(EntityPlayer p_184148_1_, double p_184148_2_, double p_184148_4_, double p_184148_6_, SoundEvent p_184148_8_, SoundCategory p_184148_9_, float p_184148_10_, float p_184148_11_)
     {
+        net.minecraftforge.event.entity.PlaySoundAtEntityEvent event = net.minecraftforge.event.ForgeEventFactory.onPlaySoundAtEntity(p_184148_1_, p_184148_8_, p_184148_9_, p_184148_10_, p_184148_11_);
+        if (event.isCanceled() || event.getSound() == null) return;
+        p_184148_8_ = event.getSound();
+        p_184148_9_ = event.getCategory();
+        p_184148_10_ = event.getVolume();
+        p_184148_11_ = event.getPitch();
+
         for (int i = 0; i < this.worldAccesses.size(); ++i)
         {
             ((IWorldEventListener)this.worldAccesses.get(i)).func_184375_a(p_184148_1_, p_184148_8_, p_184148_9_, p_184148_2_, p_184148_4_, p_184148_6_, p_184148_10_, p_184148_11_);
@@ -1027,6 +1083,9 @@
 
     public boolean spawnEntityInWorld(Entity entityIn)
     {
+        // do not drop any items while restoring blocksnapshots. Prevents dupes
+        if (!this.isRemote && (entityIn == null || (entityIn instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots))) return false;
+
         int i = MathHelper.floor_double(entityIn.posX / 16.0D);
         int j = MathHelper.floor_double(entityIn.posZ / 16.0D);
         boolean flag = entityIn.forceSpawn;
@@ -1049,6 +1108,8 @@
                 this.updateAllPlayersSleepingFlag();
             }
 
+            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entityIn, this)) && !flag) return false;
+
             this.getChunkFromChunkCoords(i, j).addEntity(entityIn);
             this.loadedEntityList.add(entityIn);
             this.onEntityAdded(entityIn);
@@ -1285,7 +1346,6 @@
         return list;
     }
 
-    @SideOnly(Side.CLIENT)
     public void removeWorldAccess(IWorldEventListener worldAccess)
     {
         this.worldAccesses.remove(worldAccess);
@@ -1348,19 +1408,38 @@
 
     public int calculateSkylightSubtracted(float p_72967_1_)
     {
+        float f = provider.getSunBrightnessFactor(p_72967_1_);
+        f = 1 - f;
+        return (int)(f * 11);
+    }
+
+    /**
+     * The current sun brightness factor for this dimension.
+     * 0.0f means no light at all, and 1.0f means maximum sunlight.
+     * Highly recommended for sunlight detection like solar panel.
+     *
+     * @return The current brightness factor
+     * */
+    public float getSunBrightnessFactor(float p_72967_1_)
+    {
         float f = this.getCelestialAngle(p_72967_1_);
         float f1 = 1.0F - (MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.5F);
         f1 = MathHelper.clamp_float(f1, 0.0F, 1.0F);
         f1 = 1.0F - f1;
         f1 = (float)((double)f1 * (1.0D - (double)(this.getRainStrength(p_72967_1_) * 5.0F) / 16.0D));
         f1 = (float)((double)f1 * (1.0D - (double)(this.getThunderStrength(p_72967_1_) * 5.0F) / 16.0D));
-        f1 = 1.0F - f1;
-        return (int)(f1 * 11.0F);
+        return f1;
     }
 
     @SideOnly(Side.CLIENT)
     public float getSunBrightness(float p_72971_1_)
     {
+        return this.provider.getSunBrightness(p_72971_1_);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public float getSunBrightnessBody(float p_72971_1_)
+    {
         float f = this.getCelestialAngle(p_72971_1_);
         float f1 = 1.0F - (MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.2F);
         f1 = MathHelper.clamp_float(f1, 0.0F, 1.0F);
@@ -1373,6 +1452,12 @@
     @SideOnly(Side.CLIENT)
     public Vec3d getSkyColor(Entity entityIn, float partialTicks)
     {
+        return this.provider.getSkyColor(entityIn, partialTicks);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public Vec3d getSkyColorBody(Entity entityIn, float partialTicks)
+    {
         float f = this.getCelestialAngle(partialTicks);
         float f1 = MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.5F;
         f1 = MathHelper.clamp_float(f1, 0.0F, 1.0F);
@@ -1380,9 +1465,7 @@
         int j = MathHelper.floor_double(entityIn.posY);
         int k = MathHelper.floor_double(entityIn.posZ);
         BlockPos blockpos = new BlockPos(i, j, k);
-        BiomeGenBase biomegenbase = this.getBiomeGenForCoords(blockpos);
-        float f2 = biomegenbase.getFloatTemperature(blockpos);
-        int l = biomegenbase.getSkyColorByTemp(f2);
+        int l = net.minecraftforge.client.ForgeHooksClient.getSkyBlendColour(this, blockpos);
         float f3 = (float)(l >> 16 & 255) / 255.0F;
         float f4 = (float)(l >> 8 & 255) / 255.0F;
         float f5 = (float)(l & 255) / 255.0F;
@@ -1442,6 +1525,11 @@
 
     public float getCurrentMoonPhaseFactor()
     {
+        return provider.getCurrentMoonPhaseFactor();
+    }
+
+    public float getCurrentMoonPhaseFactorBody()
+    {
         return WorldProvider.moonPhaseFactors[this.provider.getMoonPhase(this.worldInfo.getWorldTime())];
     }
 
@@ -1454,6 +1542,12 @@
     @SideOnly(Side.CLIENT)
     public Vec3d getCloudColour(float partialTicks)
     {
+        return this.provider.getCloudColor(partialTicks);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public Vec3d getCloudColorBody(float partialTicks)
+    {
         float f = this.getCelestialAngle(partialTicks);
         float f1 = MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.5F;
         f1 = MathHelper.clamp_float(f1, 0.0F, 1.0F);
@@ -1509,9 +1603,9 @@
         for (blockpos = new BlockPos(pos.getX(), chunk.getTopFilledSegment() + 16, pos.getZ()); blockpos.getY() >= 0; blockpos = blockpos1)
         {
             blockpos1 = blockpos.down();
-            Material material = chunk.getBlockState(blockpos1).func_185904_a();
+            IBlockState state = chunk.getBlockState(blockpos1);
 
-            if (material.blocksMovement() && material != Material.leaves)
+            if (state.func_185904_a().blocksMovement() && !state.getBlock().isLeaves(state, this, blockpos1) && !state.getBlock().isFoliage(this, blockpos1))
             {
                 break;
             }
@@ -1523,6 +1617,12 @@
     @SideOnly(Side.CLIENT)
     public float getStarBrightness(float partialTicks)
     {
+        return this.provider.getStarBrightness(partialTicks);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public float getStarBrightnessBody(float partialTicks)
+    {
         float f = this.getCelestialAngle(partialTicks);
         float f1 = 1.0F - (MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.25F);
         f1 = MathHelper.clamp_float(f1, 0.0F, 1.0F);
@@ -1574,6 +1674,12 @@
                     entity.addEntityCrashInfo(crashreportcategory);
                 }
 
+                if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
+                {
+                    net.minecraftforge.fml.common.FMLLog.severe(crashreport.getCompleteReport());
+                    removeEntity(entity);
+                }
+                else
                 throw new ReportedException(crashreport);
             }
 
@@ -1635,6 +1741,12 @@
                     CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Entity being ticked");
                     entity2.addEntityCrashInfo(crashreportcategory1);
+                    if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
+                    {
+                        net.minecraftforge.fml.common.FMLLog.severe(crashreport1.getCompleteReport());
+                        removeEntity(entity2);
+                    }
+                    else
                     throw new ReportedException(crashreport1);
                 }
             }
@@ -1684,6 +1796,13 @@
                         CrashReport crashreport2 = CrashReport.makeCrashReport(throwable, "Ticking block entity");
                         CrashReportCategory crashreportcategory2 = crashreport2.makeCategory("Block entity being ticked");
                         tileentity.addInfoToCrashReport(crashreportcategory2);
+                        if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities)
+                        {
+                            net.minecraftforge.fml.common.FMLLog.severe(crashreport2.getCompleteReport());
+                            tileentity.invalidate();
+                            this.removeTileEntity(tileentity.getPos());
+                        }
+                        else
                         throw new ReportedException(crashreport2);
                     }
                 }
@@ -1701,15 +1820,20 @@
             }
         }
 
-        this.processingLoadedTiles = false;
-
         if (!this.tileEntitiesToBeRemoved.isEmpty())
         {
+            for (Object tile : tileEntitiesToBeRemoved)
+            {
+               ((TileEntity)tile).onChunkUnload();
+            }
+
             this.tickableTileEntities.removeAll(this.tileEntitiesToBeRemoved);
             this.loadedTileEntityList.removeAll(this.tileEntitiesToBeRemoved);
             this.tileEntitiesToBeRemoved.clear();
         }
 
+        this.processingLoadedTiles = false;  //FML Move below remove to prevent CMEs
+
         this.theProfiler.endStartSection("pendingBlockEntities");
 
         if (!this.addedTileEntityList.isEmpty())
@@ -1748,7 +1872,8 @@
 
     public boolean addTileEntity(TileEntity tile)
     {
-        boolean flag = this.loadedTileEntityList.add(tile);
+        List<TileEntity> dest = processingLoadedTiles ? addedTileEntityList : loadedTileEntityList;
+        boolean flag = dest.add(tile);
 
         if (flag && tile instanceof ITickable)
         {
@@ -1782,9 +1907,13 @@
     {
         int i = MathHelper.floor_double(entityIn.posX);
         int j = MathHelper.floor_double(entityIn.posZ);
-        int k = 32;
+        boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(i >> 4, j >> 4));
+        int k = isForced ? 0 : 32;
+        boolean canUpdate = !forceUpdate || this.isAreaLoaded(i - k, 0, j - k, i + k, 0, j + k, true);
 
-        if (!forceUpdate || this.isAreaLoaded(i - k, 0, j - k, i + k, 0, j + k, true))
+        if (!canUpdate) canUpdate = net.minecraftforge.event.ForgeEventFactory.canEntityUpdate(entityIn);
+
+        if (canUpdate)
         {
             entityIn.lastTickPosX = entityIn.posX;
             entityIn.lastTickPosY = entityIn.posY;
@@ -1913,7 +2042,7 @@
                 {
                     IBlockState iblockstate = this.getBlockState(blockpos$pooledmutableblockpos.func_185343_d(k1, l1, i2));
 
-                    if (iblockstate.func_185904_a() != Material.air)
+                    if (iblockstate.getBlock().isAir(iblockstate, this, new BlockPos(k1, l1, i2)))
                     {
                         blockpos$pooledmutableblockpos.func_185344_t();
                         return true;
@@ -1983,6 +2112,10 @@
                             blockpos$pooledmutableblockpos.func_185344_t();
                             return true;
                         }
+                        else if (block.isBurning(this, new BlockPos(k1, l1, i2)))
+                        {
+                            return true;
+                        }
                     }
                 }
             }
@@ -2022,6 +2155,16 @@
                         IBlockState iblockstate = this.getBlockState(blockpos$pooledmutableblockpos);
                         Block block = iblockstate.getBlock();
 
+                        Boolean result = block.isEntityInsideMaterial(this, blockpos$pooledmutableblockpos, iblockstate, entityIn, (double)l, materialIn, false);
+                        if (result != null && result == true)
+                        {
+                            // Forge: When requested call blocks modifyAcceleration method, and more importantly cause this method to return true, which results in an entity being "inWater"
+                            flag = true;
+                            vec3d = block.modifyAcceleration(this, blockpos$pooledmutableblockpos, entityIn, vec3d);
+                            continue;
+                        }
+                        else if (result != null && result == false) continue;
+
                         if (iblockstate.func_185904_a() == materialIn)
                         {
                             double d0 = (double)((float)(l1 + 1) - BlockLiquid.getLiquidHeightPercent(((Integer)iblockstate.getValue(BlockLiquid.LEVEL)).intValue()));
@@ -2098,6 +2241,9 @@
                 {
                     IBlockState iblockstate = this.getBlockState(blockpos$pooledmutableblockpos.func_185343_d(k1, l1, i2));
 
+                    Boolean result = iblockstate.getBlock().isAABBInsideMaterial(this, blockpos$pooledmutableblockpos, bb, materialIn);
+                    if (result != null) return result;
+
                     if (iblockstate.func_185904_a() == materialIn)
                     {
                         int j2 = ((Integer)iblockstate.getValue(BlockLiquid.LEVEL)).intValue();
@@ -2130,6 +2276,7 @@
     public Explosion newExplosion(Entity entityIn, double x, double y, double z, float strength, boolean isFlaming, boolean isSmoking)
     {
         Explosion explosion = new Explosion(this, entityIn, x, y, z, strength, isFlaming, isSmoking);
+        if (net.minecraftforge.event.ForgeEventFactory.onExplosionStart(this, explosion)) return explosion;
         explosion.doExplosionA();
         explosion.doExplosionB(true);
         return explosion;
@@ -2276,19 +2423,27 @@
             else
             {
                 this.addTileEntity(tileEntityIn);
-                this.getChunkFromBlockCoords(pos).addTileEntity(pos, tileEntityIn);
+                Chunk chunk = this.getChunkFromBlockCoords(pos); //Forge add NPE protection
+                if (chunk != null) chunk.addTileEntity(pos, tileEntityIn);
             }
+            this.updateComparatorOutputLevel(pos, getBlockState(pos).getBlock()); //Notify neighbors of changes
         }
     }
 
     public void removeTileEntity(BlockPos pos)
     {
+        //Chunk chunk = this.getChunkFromBlockCoords(pos);
+        //if (chunk != null) chunk.removeTileEntity(pos);
+        //Forge ToDO: Are these patches needed anymore?
+
         TileEntity tileentity = this.getTileEntity(pos);
 
         if (tileentity != null && this.processingLoadedTiles)
         {
             tileentity.invalidate();
             this.addedTileEntityList.remove(tileentity);
+            if (!(tileentity instanceof ITickable)) //Forge: If they are not tickable they wont be removed in the update loop.
+                this.loadedTileEntityList.remove(tileentity);
         }
         else
         {
@@ -2301,6 +2456,7 @@
 
             this.getChunkFromBlockCoords(pos).removeTileEntity(pos);
         }
+        this.updateComparatorOutputLevel(pos, getBlockState(pos).getBlock()); //Notify neighbors of changes
     }
 
     public void markTileEntityForRemoval(TileEntity tileEntityIn)
@@ -2327,7 +2483,7 @@
             if (chunk != null && !chunk.isEmpty())
             {
                 IBlockState iblockstate = this.getBlockState(pos);
-                return iblockstate.func_185904_a().isOpaque() && iblockstate.func_185917_h();
+                return iblockstate.getBlock().isNormalCube(iblockstate, this, pos);
             }
             else
             {
@@ -2350,6 +2506,7 @@
     {
         this.spawnHostileMobs = hostile;
         this.spawnPeacefulMobs = peaceful;
+        this.provider.setAllowedSpawnTypes(hostile, peaceful);
     }
 
     public void tick()
@@ -2359,6 +2516,11 @@
 
     protected void calculateInitialWeather()
     {
+        this.provider.calculateInitialWeather();
+    }
+
+    public void calculateInitialWeatherBody()
+    {
         if (this.worldInfo.isRaining())
         {
             this.rainingStrength = 1.0F;
@@ -2372,6 +2534,11 @@
 
     protected void updateWeather()
     {
+        this.provider.updateWeather();
+    }
+
+    public void updateWeatherBody()
+    {
         if (!this.provider.getHasNoSky())
         {
             if (!this.isRemote)
@@ -2491,6 +2658,11 @@
 
     public boolean canBlockFreeze(BlockPos pos, boolean noWaterAdj)
     {
+        return this.provider.canBlockFreeze(pos, noWaterAdj);
+    }
+
+    public boolean canBlockFreezeBody(BlockPos pos, boolean noWaterAdj)
+    {
         BiomeGenBase biomegenbase = this.getBiomeGenForCoords(pos);
         float f = biomegenbase.getFloatTemperature(pos);
 
@@ -2532,6 +2704,11 @@
 
     public boolean canSnowAt(BlockPos pos, boolean checkLight)
     {
+        return this.provider.canSnowAt(pos, checkLight);
+    }
+
+    public boolean canSnowAtBody(BlockPos pos, boolean checkLight)
+    {
         BiomeGenBase biomegenbase = this.getBiomeGenForCoords(pos);
         float f = biomegenbase.getFloatTemperature(pos);
 
@@ -2549,7 +2726,7 @@
             {
                 IBlockState iblockstate = this.getBlockState(pos);
 
-                if (iblockstate.func_185904_a() == Material.air && Blocks.snow_layer.canPlaceBlockAt(this, pos))
+                if (iblockstate.getBlock().isAir(iblockstate, this, pos) && Blocks.snow_layer.canPlaceBlockAt(this, pos))
                 {
                     return true;
                 }
@@ -2581,10 +2758,11 @@
         else
         {
             IBlockState iblockstate = this.getBlockState(pos);
-            int i = lightType == EnumSkyBlock.SKY ? 0 : iblockstate.func_185906_d();
-            int j = iblockstate.func_185891_c();
+            int blockLight = iblockstate.getBlock().getLightValue(iblockstate, this, pos);
+            int i = lightType == EnumSkyBlock.SKY ? 0 : blockLight;
+            int j = iblockstate.getBlock().getLightOpacity(iblockstate, this, pos);
 
-            if (j >= 15 && iblockstate.func_185906_d() > 0)
+            if (j >= 15 && blockLight > 0)
             {
                 j = 1;
             }
@@ -2683,7 +2861,7 @@
                                     int j4 = j2 + enumfacing.getFrontOffsetY();
                                     int k4 = k2 + enumfacing.getFrontOffsetZ();
                                     blockpos$pooledmutableblockpos.func_185343_d(i4, j4, k4);
-                                    int l4 = Math.max(1, this.getBlockState(blockpos$pooledmutableblockpos).func_185891_c());
+                                    int l4 = Math.max(1, this.getBlockState(blockpos$pooledmutableblockpos).getBlock().getLightOpacity(this.getBlockState(blockpos$pooledmutableblockpos), this, blockpos$pooledmutableblockpos));
                                     i3 = this.getLightFor(lightType, blockpos$pooledmutableblockpos);
 
                                     if (i3 == l2 - l4 && j < this.lightUpdateBlockList.length)
@@ -2789,10 +2967,10 @@
     public List<Entity> getEntitiesInAABBexcluding(Entity entityIn, AxisAlignedBB boundingBox, Predicate <? super Entity > predicate)
     {
         List<Entity> list = Lists.<Entity>newArrayList();
-        int i = MathHelper.floor_double((boundingBox.minX - 2.0D) / 16.0D);
-        int j = MathHelper.floor_double((boundingBox.maxX + 2.0D) / 16.0D);
-        int k = MathHelper.floor_double((boundingBox.minZ - 2.0D) / 16.0D);
-        int l = MathHelper.floor_double((boundingBox.maxZ + 2.0D) / 16.0D);
+        int i = MathHelper.floor_double((boundingBox.minX - MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.floor_double((boundingBox.maxX + MAX_ENTITY_RADIUS) / 16.0D);
+        int k = MathHelper.floor_double((boundingBox.minZ - MAX_ENTITY_RADIUS) / 16.0D);
+        int l = MathHelper.floor_double((boundingBox.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
 
         for (int i1 = i; i1 <= j; ++i1)
         {
@@ -2845,10 +3023,10 @@
 
     public <T extends Entity> List<T> getEntitiesWithinAABB(Class <? extends T > clazz, AxisAlignedBB aabb, Predicate <? super T > filter)
     {
-        int i = MathHelper.floor_double((aabb.minX - 2.0D) / 16.0D);
-        int j = MathHelper.ceiling_double_int((aabb.maxX + 2.0D) / 16.0D);
-        int k = MathHelper.floor_double((aabb.minZ - 2.0D) / 16.0D);
-        int l = MathHelper.ceiling_double_int((aabb.maxZ + 2.0D) / 16.0D);
+        int i = MathHelper.floor_double((aabb.minX - MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.ceiling_double_int((aabb.maxX + MAX_ENTITY_RADIUS) / 16.0D);
+        int k = MathHelper.floor_double((aabb.minZ - MAX_ENTITY_RADIUS) / 16.0D);
+        int l = MathHelper.ceiling_double_int((aabb.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
         List<T> list = Lists.<T>newArrayList();
 
         for (int i1 = i; i1 < j; ++i1)
@@ -2926,11 +3104,13 @@
 
     public void loadEntities(Collection<Entity> entityCollection)
     {
-        this.loadedEntityList.addAll(entityCollection);
-
         for (Entity entity : entityCollection)
         {
-            this.onEntityAdded(entity);
+            if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity, this)))
+            {
+                loadedEntityList.add(entity);
+                this.onEntityAdded(entity);
+            }
         }
     }
 
@@ -2943,7 +3123,7 @@
     {
         IBlockState iblockstate = this.getBlockState(pos);
         AxisAlignedBB axisalignedbb = p_175716_3_ ? null : blockIn.getDefaultState().func_185890_d(this, pos);
-        return axisalignedbb != Block.field_185506_k && !this.checkNoEntityCollision(axisalignedbb.func_186670_a(pos), entityIn) ? false : (iblockstate.func_185904_a() == Material.circuits && blockIn == Blocks.anvil ? true : iblockstate.func_185904_a().isReplaceable() && blockIn.canReplace(this, pos, side, itemStackIn));
+        return axisalignedbb != Block.field_185506_k && !this.checkNoEntityCollision(axisalignedbb.func_186670_a(pos), entityIn) ? false : (iblockstate.func_185904_a() == Material.circuits && blockIn == Blocks.anvil ? true : iblockstate.getBlock().isReplaceable(this, pos) && blockIn.canReplace(this, pos, side, itemStackIn));
     }
 
     public int getSeaLevel()
@@ -3026,7 +3206,7 @@
     public int getRedstonePower(BlockPos pos, EnumFacing facing)
     {
         IBlockState iblockstate = this.getBlockState(pos);
-        return iblockstate.func_185915_l() ? this.getStrongPower(pos) : iblockstate.func_185911_a(this, pos, facing);
+        return iblockstate.getBlock().shouldCheckWeakPower(iblockstate, this, pos, facing) ? this.getStrongPower(pos) : iblockstate.func_185911_a(this, pos, facing);
     }
 
     public boolean isBlockPowered(BlockPos pos)
@@ -3215,7 +3395,7 @@
 
     public long getSeed()
     {
-        return this.worldInfo.getSeed();
+        return this.provider.getSeed();
     }
 
     public long getTotalWorldTime()
@@ -3225,17 +3405,17 @@
 
     public long getWorldTime()
     {
-        return this.worldInfo.getWorldTime();
+        return this.provider.getWorldTime();
     }
 
     public void setWorldTime(long time)
     {
-        this.worldInfo.setWorldTime(time);
+        this.provider.setWorldTime(time);
     }
 
     public BlockPos getSpawnPoint()
     {
-        BlockPos blockpos = new BlockPos(this.worldInfo.getSpawnX(), this.worldInfo.getSpawnY(), this.worldInfo.getSpawnZ());
+        BlockPos blockpos = this.provider.getSpawnPoint();
 
         if (!this.getWorldBorder().contains(blockpos))
         {
@@ -3247,7 +3427,7 @@
 
     public void setSpawnPoint(BlockPos pos)
     {
-        this.worldInfo.setSpawn(pos);
+        this.provider.setSpawnPoint(pos);
     }
 
     @SideOnly(Side.CLIENT)
@@ -3267,12 +3447,18 @@
 
         if (!this.loadedEntityList.contains(entityIn))
         {
+            if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entityIn, this)))
             this.loadedEntityList.add(entityIn);
         }
     }
 
     public boolean isBlockModifiable(EntityPlayer player, BlockPos pos)
     {
+        return this.provider.canMineBlock(player, pos);
+    }
+
+    public boolean canMineBlockBody(EntityPlayer player, BlockPos pos)
+    {
         return true;
     }
 
@@ -3366,8 +3552,7 @@
 
     public boolean isBlockinHighHumidity(BlockPos pos)
     {
-        BiomeGenBase biomegenbase = this.getBiomeGenForCoords(pos);
-        return biomegenbase.isHighHumidity();
+        return this.provider.isBlockHighHumidity(pos);
     }
 
     public MapStorage getMapStorage()
@@ -3426,12 +3611,12 @@
 
     public int getHeight()
     {
-        return 256;
+        return this.provider.getHeight();
     }
 
     public int getActualHeight()
     {
-        return this.provider.getHasNoSky() ? 128 : 256;
+        return this.provider.getActualHeight();
     }
 
     public Random setRandomSeed(int p_72843_1_, int p_72843_2_, int p_72843_3_)
@@ -3481,7 +3666,7 @@
     @SideOnly(Side.CLIENT)
     public double getHorizon()
     {
-        return this.worldInfo.getTerrainType() == WorldType.FLAT ? 0.0D : 63.0D;
+        return provider.getHorizon();
     }
 
     public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress)
@@ -3515,7 +3700,7 @@
 
     public void updateComparatorOutputLevel(BlockPos pos, Block blockIn)
     {
-        for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
+        for (EnumFacing enumfacing : EnumFacing.VALUES)
         {
             BlockPos blockpos = pos.offset(enumfacing);
 
@@ -3523,18 +3708,14 @@
             {
                 IBlockState iblockstate = this.getBlockState(blockpos);
 
-                if (Blocks.unpowered_comparator.func_185547_C(iblockstate))
+                iblockstate.getBlock().onNeighborChange(this, blockpos, pos);
+                if (iblockstate.getBlock().isNormalCube(iblockstate, this, blockpos))
                 {
-                    iblockstate.getBlock().onNeighborBlockChange(this, blockpos, iblockstate, blockIn);
-                }
-                else if (iblockstate.func_185915_l())
-                {
                     blockpos = blockpos.offset(enumfacing);
                     iblockstate = this.getBlockState(blockpos);
-
-                    if (Blocks.unpowered_comparator.func_185547_C(iblockstate))
+                    if (iblockstate.getBlock().getWeakChanges(this, blockpos))
                     {
-                        iblockstate.getBlock().onNeighborBlockChange(this, blockpos, iblockstate, blockIn);
+                        iblockstate.getBlock().onNeighborChange(this, blockpos, pos);
                     }
                 }
             }
@@ -3600,6 +3781,87 @@
         return i >= -k && i <= k && j >= -k && j <= k;
     }
 
+    /* ======================================== FORGE START =====================================*/
+    /**
+     * Determine if the given block is considered solid on the
+     * specified side.  Used by placement logic.
+     *
+     * @param pos Block Position
+     * @param side The Side in question
+     * @return True if the side is solid
+    */
+    public boolean isSideSolid(BlockPos pos, EnumFacing side)
+    {
+       return isSideSolid(pos, side, false);
+    }
+
+    /**
+     * Determine if the given block is considered solid on the
+     * specified side.  Used by placement logic.
+     *
+     * @param pos Block Position
+     * @param side The Side in question
+     * @param _default The default to return if the block doesn't exist.
+     * @return True if the side is solid
+     */
+    @Override
+    public boolean isSideSolid(BlockPos pos, EnumFacing side, boolean _default)
+    {
+        if (!this.isValid(pos)) return _default;
+
+        Chunk chunk = getChunkFromBlockCoords(pos);
+        if (chunk == null || chunk.isEmpty()) return _default;
+        return getBlockState(pos).isSideSolid(this, pos, side);
+    }
+
+    /**
+     * Get the persistent chunks for this world
+     *
+     * @return
+     */
+    public com.google.common.collect.ImmutableSetMultimap<ChunkCoordIntPair, net.minecraftforge.common.ForgeChunkManager.Ticket> getPersistentChunks()
+    {
+        return net.minecraftforge.common.ForgeChunkManager.getPersistentChunksFor(this);
+    }
+
+    public Iterator<Chunk> getPersistentChunkIterable(Iterator<Chunk> chunkIterator)
+    {
+        return net.minecraftforge.common.ForgeChunkManager.getPersistentChunksIterableFor(this, chunkIterator);
+    }
+    /**
+     * Readded as it was removed, very useful helper function
+     *
+     * @param pos Block position
+     * @return The blocks light opacity
+     */
+    public int getBlockLightOpacity(BlockPos pos)
+    {
+        if (!this.isValid(pos)) return 0;
+        return getChunkFromBlockCoords(pos).getBlockLightOpacity(pos);
+    }
+
+    /**
+     * Returns a count of entities that classify themselves as the specified creature type.
+     */
+    public int countEntities(net.minecraft.entity.EnumCreatureType type, boolean forSpawnCount)
+    {
+        int count = 0;
+        for (int x = 0; x < loadedEntityList.size(); x++)
+        {
+            if (((Entity)loadedEntityList.get(x)).isCreatureType(type, forSpawnCount))
+            {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    protected MapStorage perWorldStorage; //Moved to a getter to simulate final without being final so we can load in subclasses.
+    public MapStorage getPerWorldStorage()
+    {
+        return perWorldStorage;
+    }
+
     public void func_184135_a(Packet<?> p_184135_1_)
     {
         throw new UnsupportedOperationException("Can\'t send packets to server unless you\'re on the client.");
