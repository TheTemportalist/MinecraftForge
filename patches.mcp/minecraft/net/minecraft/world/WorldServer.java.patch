--- ../src-base/minecraft/net/minecraft/world/WorldServer.java
+++ ../src-work/minecraft/net/minecraft/world/WorldServer.java
@@ -94,30 +94,46 @@
     private static final List<WeightedRandomChestContent> bonusChestContent = Lists.newArrayList(new WeightedRandomChestContent[] {new WeightedRandomChestContent(Items.stick, 0, 1, 3, 10), new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.planks), 0, 1, 3, 10), new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.log), 0, 1, 3, 10), new WeightedRandomChestContent(Items.stone_axe, 0, 1, 1, 3), new WeightedRandomChestContent(Items.wooden_axe, 0, 1, 1, 5), new WeightedRandomChestContent(Items.stone_pickaxe, 0, 1, 1, 3), new WeightedRandomChestContent(Items.wooden_pickaxe, 0, 1, 1, 5), new WeightedRandomChestContent(Items.apple, 0, 2, 3, 5), new WeightedRandomChestContent(Items.bread, 0, 2, 3, 3), new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.log2), 0, 1, 3, 10)});
     private List<NextTickListEntry> pendingTickListEntriesThisTick = Lists.<NextTickListEntry>newArrayList();
 
+    /** Stores the recently processed (lighting) chunks */
+    protected Set<ChunkCoordIntPair> doneChunks = new java.util.HashSet<ChunkCoordIntPair>();
+    public List<Teleporter> customTeleporters = new ArrayList<Teleporter>();
+    private static boolean initChest = false;
+    public static void fillChestHook()
+    {
+        if (!initChest)
+            net.minecraftforge.common.ChestGenHooks.init(net.minecraftforge.common.ChestGenHooks.BONUS_CHEST, bonusChestContent, 10, 10);
+        initChest = true;
+    }
+
     public WorldServer(MinecraftServer server, ISaveHandler saveHandlerIn, WorldInfo info, int dimensionId, Profiler profilerIn)
     {
         super(saveHandlerIn, info, WorldProvider.getProviderForDimension(dimensionId), profilerIn, false);
         this.mcServer = server;
         this.theEntityTracker = new EntityTracker(this);
         this.thePlayerManager = new PlayerManager(this);
+        // Guarantee the dimension ID was not reset by the provider
+        int providerDim = this.provider.dimensionId;
         this.provider.registerWorld(this);
+        this.provider.dimensionId = providerDim;
         this.chunkProvider = this.createChunkProvider();
+        perWorldStorage = new MapStorage(new net.minecraftforge.common.WorldSpecificSaveHandler((WorldServer)this, saveHandlerIn));
         this.worldTeleporter = new Teleporter(this);
         this.calculateInitialSkylight();
         this.calculateInitialWeather();
         this.getWorldBorder().setSize(server.getMaxWorldSize());
+        net.minecraftforge.common.DimensionManager.setWorld(dimensionId, this);
     }
 
     public World init()
     {
         this.mapStorage = new MapStorage(this.saveHandler);
         String s = VillageCollection.fileNameForProvider(this.provider);
-        VillageCollection villagecollection = (VillageCollection)this.mapStorage.loadData(VillageCollection.class, s);
+        VillageCollection villagecollection = (VillageCollection)this.perWorldStorage.loadData(VillageCollection.class, s);
 
         if (villagecollection == null)
         {
             this.villageCollectionObj = new VillageCollection(this);
-            this.mapStorage.setData(s, this.villageCollectionObj);
+            this.perWorldStorage.setData(s, this.villageCollectionObj);
         }
         else
         {
@@ -210,6 +226,10 @@
         this.villageSiege.tick();
         this.theProfiler.endStartSection("portalForcer");
         this.worldTeleporter.removeStalePortalLocations(this.getTotalWorldTime());
+        for (Teleporter tele : customTeleporters)
+        {
+            tele.removeStalePortalLocations(getTotalWorldTime());
+        }
         this.theProfiler.endSection();
         this.sendQueuedBlockEvents();
     }
@@ -217,12 +237,14 @@
     public BiomeGenBase.SpawnListEntry getSpawnListEntryForTypeAt(EnumCreatureType creatureType, BlockPos pos)
     {
         List<BiomeGenBase.SpawnListEntry> list = this.getChunkProvider().getPossibleCreatures(creatureType, pos);
+        list = net.minecraftforge.event.ForgeEventFactory.getPotentialSpawns(this, creatureType, pos, list);
         return list != null && !list.isEmpty() ? (BiomeGenBase.SpawnListEntry)WeightedRandom.getRandomItem(this.rand, list) : null;
     }
 
     public boolean canCreatureTypeSpawnHere(EnumCreatureType creatureType, BiomeGenBase.SpawnListEntry spawnListEntry, BlockPos pos)
     {
         List<BiomeGenBase.SpawnListEntry> list = this.getChunkProvider().getPossibleCreatures(creatureType, pos);
+        list = net.minecraftforge.event.ForgeEventFactory.getPotentialSpawns(this, creatureType, pos, list);
         return list != null && !list.isEmpty() ? list.contains(spawnListEntry) : false;
     }
 
@@ -268,10 +290,7 @@
 
     private void resetRainAndThunder()
     {
-        this.worldInfo.setRainTime(0);
-        this.worldInfo.setRaining(false);
-        this.worldInfo.setThunderTime(0);
-        this.worldInfo.setThundering(false);
+        this.provider.resetRainAndThunder();
     }
 
     public boolean areAllPlayersAsleep()
@@ -349,7 +368,7 @@
                 chunk.func_150804_b(false);
                 this.theProfiler.endStartSection("thunder");
 
-                if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+                if (this.provider.canDoLightning(chunk) && this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
                 {
                     this.updateLCG = this.updateLCG * 3 + 1013904223;
                     int i1 = this.updateLCG >> 2;
@@ -363,7 +382,7 @@
 
                 this.theProfiler.endStartSection("iceandsnow");
 
-                if (this.rand.nextInt(16) == 0)
+                if (this.provider.canDoRainSnowIce(chunk) && this.rand.nextInt(16) == 0)
                 {
                     this.updateLCG = this.updateLCG * 3 + 1013904223;
                     int k2 = this.updateLCG >> 2;
@@ -456,6 +475,9 @@
             if (blockIn.requiresUpdates())
             {
                 i = 8;
+                //Keeping here as a note for future when it may be restored.
+                boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(nextticklistentry.position.getX() >> 4, nextticklistentry.position.getZ() >> 4));
+                i = isForced ? 0 : 8;
 
                 if (this.isAreaLoaded(nextticklistentry.position.add(-i, -i, -i), nextticklistentry.position.add(i, i, i)))
                 {
@@ -508,7 +530,7 @@
 
     public void updateEntities()
     {
-        if (this.playerEntities.isEmpty())
+        if (this.playerEntities.isEmpty() && getPersistentChunks().isEmpty())
         {
             if (this.updateEntityTick++ >= 1200)
             {
@@ -573,6 +595,9 @@
                 {
                     NextTickListEntry nextticklistentry1 = (NextTickListEntry)iterator.next();
                     iterator.remove();
+                    //Keeping here as a note for future when it may be restored.
+                    //boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(nextticklistentry.xCoord >> 4, nextticklistentry.zCoord >> 4));
+                    //byte b0 = isForced ? 0 : 8;
                     int k = 0;
 
                     if (this.isAreaLoaded(nextticklistentry1.position.add(-k, -k, -k), nextticklistentry1.position.add(k, k, k)))
@@ -696,22 +721,40 @@
     {
         List<TileEntity> list = Lists.<TileEntity>newArrayList();
 
-        for (int i = 0; i < this.loadedTileEntityList.size(); ++i)
+        //Forge: Optimize this loop to only grab from the chunks it needs
+        for (int x = (minX & ~0x0F); x < maxX; x += 16)
         {
-            TileEntity tileentity = (TileEntity)this.loadedTileEntityList.get(i);
-            BlockPos blockpos = tileentity.getPos();
-
-            if (blockpos.getX() >= minX && blockpos.getY() >= minY && blockpos.getZ() >= minZ && blockpos.getX() < maxX && blockpos.getY() < maxY && blockpos.getZ() < maxZ)
+            for (int z = (minZ & ~0x0F); z < maxZ; z += 16) // & ~0xF Floors it by 16. Yay bitmath!
             {
-                list.add(tileentity);
+                if (!this.isChunkLoaded(x >> 4, z >> 4, true)) continue; //Prevent loading extra chunks to just read data. This causes orphaned chunks that never unload.
+                Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+                if (chunk != null && !chunk.isEmpty())
+                {
+                    for (TileEntity entity : chunk.getTileEntityMap().values())
+                    {
+                        if (!entity.isInvalid())
+                        {
+                            BlockPos pos = entity.getPos();
+                            if (pos.getX() >= minX && pos.getY() >= minY && pos.getZ() >= minZ &&
+                                pos.getX() <  maxX && pos.getY() <  maxY && pos.getZ() <  maxZ)
+                            {
+                                list.add(entity);
+                            }
+
+                        }
+                    }
+                }
             }
         }
-
         return list;
     }
 
     public boolean isBlockModifiable(EntityPlayer player, BlockPos pos)
     {
+        return super.isBlockModifiable(player, pos);
+    }
+    public boolean canMineBlockBody(EntityPlayer player, BlockPos pos)
+    {
         return !this.mcServer.isBlockProtected(this, pos, player) && this.getWorldBorder().contains(pos);
     }
 
@@ -777,6 +820,7 @@
         }
         else
         {
+            if (net.minecraftforge.event.ForgeEventFactory.onCreateWorldSpawn(this, p_73052_1_)) return;
             this.findingSpawnPoint = true;
             WorldChunkManager worldchunkmanager = this.provider.getWorldChunkManager();
             List<BiomeGenBase> list = worldchunkmanager.getBiomesToSpawnIn();
@@ -822,7 +866,7 @@
 
     protected void createBonusChest()
     {
-        WorldGeneratorBonusChest worldgeneratorbonuschest = new WorldGeneratorBonusChest(bonusChestContent, 10);
+        WorldGeneratorBonusChest worldgeneratorbonuschest = net.minecraftforge.common.ForgeHooks.getBonusChest(rand);
 
         for (int i = 0; i < 10; ++i)
         {
@@ -859,6 +903,7 @@
             }
 
             this.chunkProvider.saveChunks(p_73044_1_, progressCallback);
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Save(this));
 
             for (Chunk chunk : Lists.newArrayList(this.theChunkProviderServer.func_152380_a()))
             {
@@ -892,6 +937,7 @@
         this.worldInfo.setBorderLerpTime(this.getWorldBorder().getTimeUntilTarget());
         this.saveHandler.saveWorldInfoWithPlayer(this.worldInfo, this.mcServer.getConfigurationManager().getHostPlayerData());
         this.mapStorage.saveAllData();
+        this.perWorldStorage.saveAllData();
     }
 
     public void onEntityAdded(Entity entityIn)
@@ -947,6 +993,7 @@
     public Explosion newExplosion(Entity entityIn, double x, double y, double z, float strength, boolean isFlaming, boolean isSmoking)
     {
         Explosion explosion = new Explosion(this, entityIn, x, y, z, strength, isFlaming, isSmoking);
+        if (net.minecraftforge.event.ForgeEventFactory.onExplosionStart(this, explosion)) return explosion;
         explosion.doExplosionA();
         explosion.doExplosionB(false);
 
@@ -1026,19 +1073,23 @@
             this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(8, this.thunderingStrength), this.provider.getDimensionId());
         }
 
+        /* The function in use here has been replaced in order to only send the weather info to players in the correct dimension,
+         * rather than to all players on the server. This is what causes the client-side rain, as the
+         * client believes that it has started raining locally, rather than in another dimension.
+         */
         if (flag != this.isRaining())
         {
             if (flag)
             {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(2, 0.0F));
+                this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(2, 0.0F), this.provider.dimensionId);
             }
             else
             {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(1, 0.0F));
+                this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(1, 0.0F), this.provider.dimensionId);
             }
 
-            this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(7, this.rainingStrength));
-            this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(8, this.thunderingStrength));
+            this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(7, this.rainingStrength), this.provider.dimensionId);
+            this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(8, this.thunderingStrength), this.provider.dimensionId);
         }
     }
 
@@ -1104,6 +1155,11 @@
         return this.mcServer.isCallingFromMinecraftThread();
     }
 
+    public java.io.File getChunkSaveLocation()
+    {
+        return ((net.minecraft.world.chunk.storage.AnvilChunkLoader)theChunkProviderServer.chunkLoader).chunkSaveLocation;
+    }
+
     static class ServerBlockEventList extends ArrayList<BlockEventData>
         {
             private ServerBlockEventList()
